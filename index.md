---
layout: post
title: "Portfolio"
date:   2018-02-01 09:42:44 -0800
---

[Download resume version as .pdf]({{ "assets/williambundy_resume.pdf" | absolute_url }})

## Game Projects

### [Traceteroids]({{ "assets/Traceteroids.zip" | absolute_url }})

(2017, C)

I put this together partly for fun, partly to explore raytracing. It works well
enough--there's some slowdown at high resolutions--but manages to be a playable 
version of asteroids.

![Traceteroids1]({{ "assets/Traceteroids1.gif" | absolute_url }}){: width="450px"}
![Traceteroids2]({{ "assets/Traceteroids2.gif" | absolute_url }}){: width="450px"}
<br />
### [Haven](https://ldjam.com/events/ludum-dare/40/haven)

(2017, C) Ludum Dare 40

I had a lot of fun making Haven. While there's no way to separate the jam version's
gameplay code from the graphics code, I feel the project itself is very expandable.
My latest version of the code uses OpenGLES and the msdf fonts generated by wiggle,
which would make it a very easy port to mobile.

![haven]({{ "assets/haven.gif" | absolute_url }})

<br />
### [DustyWalkingSim]({{ "assets/DustyWalkingSim.zip" | absolute_url }})

(2017, C)

With this one, I got to work on improving my physics code. While I kept collision
detection simple by only using circles, it wouldn't be possible to have such a 
large world without the infinite grid I implemented. Other than acting as a spacial
hash, it also has a couple other nice properties:

- Pointers to bodies stay constant, so it's easy to keep track of them.
- It's easy to query an area, allowing you to only simulate things close to the player
or other points of interest.

However, it comes with a downside: internally, physics objects are stored in
a linked list of arrays, which ends up being tricky to work with, at best. 

This project was the motivation for writing `wb_alloc.h`; I found the allocators I
was using useful enough to standardize them for use in other projects.

![dusty1]({{ "assets/DustyWalkingSim1.gif" | absolute_url }})
![dusty2]({{ "assets/DustyWalkingSim2.gif" | absolute_url }})

<br />
### [Rituals](https://github.com/WilliamBundy/rituals-game)

(2016-18, C/C++)

Rituals was my first C/C++ project that really went anywhere. When I look back,
I find its value in the experience it gave me and progress it sparked; a lot 
of the experimental code in Rituals has matured and found itself in other projects:

- Wirpmht is its own thing now; it was originally just titled "metaprogram".
- I've revisited the math and physics coded; DustyWalkingSim and Traceteroids use a similar system.
- My newer OpenGL setup is probably most prominent in wiggle's demo, but I have several
other working versions spanning different OpenGL versions.

![rituals1]({{ "assets/Rituals1.gif" | absolute_url }})
![rituals2]({{ "assets/Rituals2.gif" | absolute_url }})

<br />
### [Sparse]({{ "assets/Sparse.zip" | absolute_url }})

(2014-15, C#)

Sparse has its roots in a Flash game I worked on while at university. Eventually I 
switched to C# and SDL2 with a very Flash-like design. Over time, I found that there
were better ways to approach problems in the specific context of the game, which
eventually lead me to use C/C++ full time.

Of all the systems that got reworked over time, the definition loading/game data system was
the biggest one. I wrote the definitions in JSON and had to read them into the game.
While the initial system copied everything by hand, subsequent systems used reflection
instead. The final iteration went in-depth with a combination of Json.Net, reflection,
and attributes to make it as easy to use as possible.


![sparse3]({{ "assets/Sparse3.gif" | absolute_url }})
![sparse2]({{ "assets/Sparse2.gif" | absolute_url }})
![sparse1]({{ "assets/Sparse1.gif" | absolute_url }})

<br />
<br />
<br />

## Tool Projects

### [wiggle](https://github.com/WilliamBundy/wiggle)
(2018, C/C++)

Wiggle is a tool that renders glyphs and makes texture atlases, using msdfgen, 
FreeType, kerndump, and a couple stb_libs. It includes a game similar to Space
Invaders, called "Text Invaders" to demonstrate how glyphs look when rendered. 
It's not designed to be an all-encompassing font rendering and layout solution, 
merely a simple one for decent looking text in English games.

- Easy to use: the interface is simple and the the output is easy to manage on the 
command line.
- Can extract kerning data for the latin alphabet from OTF fonts, which isn't 
possible with raw FreeType.
- Uses multi channel signed-distance field rendering for crisp outlines even at 
relatively small resolutions.
- Implements simple file formats that make it easy to use the output in other programs.

![Example output]({{ "assets/wiggle.png" | absolute_url }}){: width="600px"}
![Demo game]({{ "assets/TextInvaders.gif" | absolute_url }})

### [wb_alloc](https://github.com/WilliamBundy/wb_alloc)
(2017, C)

`wb_alloc.h` is both a system for managing virtual memory and a few allocators built
on that system. `MemoryArena` serves as both a linear and stack allocator, `MemoryPool`
is just that, allowing for efficient allocation and freeing of fixed-size objects,
and `TaggedHeap` (designed after the one in a Naughty Dog GDC talk) can free tagged
groups of allocations at once.

- Virtual memory use allows for in-place expanding arrays on modern OSes, which 
isn't offered by malloc/free style allocators.
- Can be dropped into a project without including system headers.
- I've used it in my own code to dramatically simplify memory allocation patterns.

### [VMFsketch](https://github.com/WilliamBundy/vmfsketch)
(2017, C)

VMFsketch is as attempt at building a top-down map editor for quickly laying out maps,
largely for Team Fortress 2. While it's definitely a reasonable tool, it needs more
work to actually be useful; specifically, undo support, rotation, and better 
visualization. However, I find the modal, two-handed interaction model easy to use,
and overall concept quite valuable.

- Barring bugs, the editor makes it impossible to generate invalid geometry. When
a shape is modified, the editor generates a convex hull and re-orders the points.
- Uses and extends the [nuklear](https://github.com/vurtun/nuklear) UI library. 

![View in editor]({{ "assets/sketch.png" | absolute_url }}){: width="400px"}
![View in hammer]({{ "assets/hammer.png" | absolute_url }}){: width="400px"}

### [wirmpht](https://github.com/WilliamBundy/wirmpht)

(2016-17, C/C++)

I despise writing headers. It's a blatant violation of don't-repeat-yourself form,
and doubles the work required to change things like function prototypes. Not to 
mention, moving structure definitions to headers separates them from the code
they interact with. While they're a necessary evil in some forms of C, having a 
tool that generates them for me has been a big help. While it's got some bugs, 
the metaprogramming features don't work, and its internals are mostly indecipherable
to me now, it'll take more effort to replace than its output saves me right now.

- Parses, stores, and represents nested and anonymous structures.
- Follows `#include` directives, making it trivial to use with single-translation-unit
build systems.
- Internal structure is separate from representation; it's easy to add new outputs. 
For example, I added an output to convert C headers to [Odin](http://odin-lang.org).


<br />
<br />
<br />

## Other Game Jam Projects
<br />
### Potential

(2015, C#) Ludum Dare 30

Potential is a puzzle-platformer based around preserving potential energy. The game
itself re-uses much of Sparse's source code.

![potential1]({{ "assets/Potential1.gif" | absolute_url }})
![potential2]({{ "assets/Potential2.gif" | absolute_url }})
![potential3]({{ "assets/Potential3.gif" | absolute_url }})

<br />
### [Contact Lost](https://github.com/WilliamBundy/contact-lost-ld26)

(2013, Lua/Love2d) Ludum Dare 26

Contact Lost was, for a long time, possibly my most complete project. It makes big
use of Lua features, especially tables, to handle definitions, events, and its 
inventory.

![clost1]({{ "assets/ContactLost1.gif" | absolute_url }})
![clost2]({{ "assets/ContactLost2.gif" | absolute_url }})

